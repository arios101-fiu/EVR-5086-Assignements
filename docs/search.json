[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "EVR-5086 Assignment 1 - Calculus Review",
    "section": "",
    "text": "Introduction\nAlthough the EVR-5086 class is being taught using Python, my prior experience is with R. I am also fond of sharing my work on GitHub. I have learned how GitHub pages combined with Quarto and R Studio are an extraordinary resource for developing and maintaining lab notebooks. To get better at using these tools (and the reproducibility and accessibility of my future research) I have created a html quarto book and pdf to show my work associated with the course assignments.\n\n\nSet Up\nI started by creating a GitHub account for this and potential future homework (username: arios101-fiu). Then, I created a GitHub repository with a gitignore and readme.md for this assignment (EVR-5086-Assignment1). I cloned the repository into R Studio, thereby creating a R project. I copied in a _quarto.yml and index.qmd files from another project. I updated the files, rendered, committed, and pushed. Next, I turned on GitHub pages and updated the URLs in the yml and repository. On to the assignment…",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "polynomial.html",
    "href": "polynomial.html",
    "title": "1  Polynomial Plot",
    "section": "",
    "text": "Below are the steps I took to complete the first part of EVR-5086 Assignment 1.\nIn doing this exercise in R, I started by loading the R libraries I will use in this chapter. I used {ggplot2} for plotting, and {tidyr} and {dplyr} for data wrangling.\n\n# load libraries\nlibrary(ggplot2)\nlibrary(tidyr)\nlibrary(dplyr)\n\nNext, I defined the variables and created the vectors I will need for the plot.\n\n# Define variables\na &lt;- 1\nn &lt;- 1\nb &lt;- 1\np &lt;- 2\nc &lt;- 1\nq &lt;- 3\n\n# Create x vectors from -1 to 1\nx &lt;- seq(from = -1, to = 1, by = 0.1)\n\n# Calculate the value of y for each value of x\ny &lt;- (a * (x^n)) + (b * (x^p)) + (c * (x^q))\n\n# Calculate the analytical derivatives for each value of x\ndy_dx &lt;- (a * n * (x^(n - 1))) + (b * p * (x^(p - 1))) + (c * q * (x^(q-1)))\n\n# Calculate the numerical derivatives\ndeltay &lt;- diff(y)\ndeltax &lt;- diff(x)\ndeltay_deltax &lt;- deltay / deltax\n\n# For plotting purposes, derive the midpoint\ndeltax_vec &lt;- x[-length(x)] + deltax/2\n\nMy next goal was to unite all of the vectors into a long data format. I did this by creating a data frame, then pivoting the data to only have the values that will be plotted on the x and y axis, as well as a label. Later, I will use my “linetype” label to define line types as well as the colors and shapes in my plot.\n\n# Build data frames for plot\nplot_prep &lt;- data.frame(x, y, dy_dx) |&gt;\n  dplyr::rename(Polynomial = y,\n                \"Analytical derivative\" = dy_dx)\n\n# Wrangle for ggplot\nplot_tidy &lt;- plot_prep |&gt;\n  tidyr::pivot_longer(!x, names_to = \"linetype\", values_to = \"y\") |&gt;\n  dplyr::bind_rows(\n    data.frame(\n      x = deltax_vec, \n      y = deltay_deltax, \n      linetype = \"Numerical derivative\"\n    )\n  )\n\nLastly, I create the plot and reflect on the observations and limitations of the numerical derivative.\nFigure 1.1 shows that the numerical derivative, shown as red open circles, is very similar to the analytical derivative, shown as a blue solid line. The good match we see relates to the scale over which we calculated the numerical derivative compared to the scale of the rate of change in the polynomial. When calculating the numerical derivative, we can get the average rate of change between two points.\nNote that for the analytical derivative we are only providing the plot with information associated with x values ranging -1 to 1, in steps of 0.1. Meanwhile, the numerical derivative is plotted at the midpoints of our original segments, with x values ranging from -0.95 to 0.95. Including the numerical derivatives in the appropriate position relative to the curved lines plotted between our analytical derivatives results in an overlay of the points and the line.\nIf the numerical derivative had a significantly lower resolution (e.g. just -1 and 1), it would not match well, and would be just one point above the “U” shape of the analytical derivative at x = 0. Although that course spacing is an extreme, it helps to emphasize that “grid spacing and position of the computed derivative need to be considered.”\n\n# Plot the analytically derivative as a solid line \n# and the numerical derivative as open symbols\npolynomial_plot &lt;- ggplot(data = plot_tidy, \n                          aes(x = x, y = y, color = linetype)) +\n  geom_point(data = dplyr::filter(plot_tidy, linetype == \"Numerical derivative\"), \n             shape = 21, stroke = 1.25) +\n  geom_line(data = dplyr::filter(plot_tidy, linetype != \"Numerical derivative\")) +\n  theme(legend.title = element_blank()) +\n  scale_color_manual(values = c(4, 2, 1)) +\n  theme_minimal()\n\npolynomial_plot\n\n\n\n\n\n\n\nFigure 1.1: Plot of the polynomial defined by the values provided in EVR-5086 Assignment 1 (black line), along with analytical (blue line) and numerical derivatives (red open circle).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Polynomial Plot</span>"
    ]
  },
  {
    "objectID": "tripole.html",
    "href": "tripole.html",
    "title": "2  Solve the 2-D Laplace in Excel",
    "section": "",
    "text": "I created a 28 by 28 grid of the 2-D Laplace Equation. I included three internal “boundary values”; one high value of 4 and two low values of -2 and -3. The two low values were near each other compared to their respective distances to the high value. I allowed excel to iteratively calculate for 10,000 iterations with a minimum change of 0.0001. I saved the file as a CSV file after including explicit zeros surrounding the formulas. The dimensions of my data were 30 by 30. I rounded to four significant digits to see if it would mean that the stagnation areas would be more pronounced.\n\n3 Read in and plot contours\nI tried working on this part of the assignment in R, but I ran short on time. Instead, I pivoted to running python inside of my R Studio Project. This first chunk of code is mostly commented out. I may consider returning to this. Since much of my work is in R, I think it might still be useful for me to bring the python code and examples into my Tidyverse and R for Data Science knowledge foundation.\n\n# Load libraries\nlibrary(plot3D)\nlibrary(ggplot2)\n\n# Read in csv file\nh = as.matrix(read.csv(\"tripole.csv\", header = FALSE, row.names = NULL))\n\n# Create vectors\nx_vec &lt;- seq(-1.5, 1.4, by = 0.1)\ny_vec &lt;- seq(-1.5, 1.4, by = 0.1)\n\n# Create \"np.meshgrid\"\nX &lt;- matrix(rep(x_vec, each = length(y_vec)), nrow = length(y_vec))\nY &lt;- matrix(rep(y_vec, times = length(x_vec)), nrow = length(y_vec))\n\n# # Plot the surface\n# surf3D(\n#   x = X,\n#   y = Y,\n#   z = h,\n#   bty = \"b2\",\n#   ticktype = \"detailed\",\n#   phi = 20, theta = 30\n# )\n# \n# # Plot the contour\n# library(ggplot2)\n# \n# # Example: compute gradients with finite differences\n# dhdx &lt;- apply(h, 1, diff)  \n# dhdx &lt;- cbind(dhdx, NA)    \n# \n# dhdy &lt;- apply(h, 2, diff)  \n# dhdy &lt;- rbind(dhdy, NA)    \n# \n# # Build data frame\n# dat &lt;- expand.grid(x = x_vec, y = y_vec)\n# dat$h &lt;- c(h)\n# dat$dhdx &lt;- c(dhdx)\n# dat$dhdy &lt;- c(dhdy)\n# \n# dat &lt;- expand.grid(x = x_vec, y = y_vec)\n# dat$h &lt;- c(h)\n# dat$dhdx &lt;- c(dhdx)\n# dat$dhdy &lt;- c(dhdy)\n# \n# ggplot(dat, aes(x, y)) +\n#   geom_contour_filled(aes(z = h)) +\n#   theme_minimal()\n\nSwitch to using python to create Figure 3.1 and Figure 4.1. I did not identify any stagnation points. My low values were close together, so a saddle effect didn’t appear as it would if they were spaced farther apart.\n\n# Import packages\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Load\nh=np.loadtxt('tripole.csv',delimiter=',')\n\nx_vec=np.linspace(-1.5, 1.4, 30)\ny_vec=np.linspace(-1.5, 1.4, 30)\nX,Y = np.meshgrid(x_vec,y_vec)\n[dhdy,dhdx]=np.gradient(h,x_vec,y_vec)\n\nfig=plt.figure(figsize=[4,4],dpi=300)\nplt.contourf(X,Y,h)\nplt.colorbar()\n\n&lt;matplotlib.colorbar.Colorbar object at 0x000001D5E9A422D0&gt;\n\nplt.axis('equal')\n\n(np.float64(-1.5), np.float64(1.4), np.float64(-1.5), np.float64(1.4))\n\nplt.quiver(X, Y, -dhdx, -dhdy)\nplt.show()\n\n\n\n\n\n\n\nFigure 3.1: Plot of vector arrows using Python. The vectors indicate strength and direction of the negative gradient. The vectors are displayed over the contours of a tri-pole solution with a high value of 4 and lows of -2 and -3. The two low values were near each other compared to their respective distances to the high value.\n\n\n\n\n\n\n\n4 Plot streamlines\n\n# Plot streamlines\nplt.contourf(X,Y,h)\nplt.streamplot(X, Y, -dhdx, -dhdy)\n\n&lt;matplotlib.streamplot.StreamplotSet object at 0x000001D5EBC22D90&gt;\n\nplt.axis('equal')\n\n(np.float64(-1.5), np.float64(1.4), np.float64(-1.5), np.float64(1.4))\n\nplt.show()\n\n\n\n\n\n\n\nFigure 4.1: Plot of streamlines using Python. The streamlines are displayed over the contours of a tri-pole solution with a high value of 4 and lows of -2 and -3. . The two low values were near each other compared to their respective distances to the high value.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Solve the 2-D Laplace in Excel</span>"
    ]
  }
]